JVM基础知识
	1、JDK&JRE&JVM
		官方文档：https://docs.oracle.com/javase/8/docs/
	2、运行时数据区
			JVM 能涉及非常庞大的一块知识体系，比如内存结构、垃圾回收、类加
		载、性能调优、JVM 自身优化技术、执行引擎、类文件结构、监控工具等。
		但是在所有的知识体系中，都或多或少跟内存结构有一定的关系： 比如垃
		圾回收回收的就是内存、类加载加载到的地方也是内存、性能优化也涉及到内
		存优化、执行引擎与内存密不可分、类文件结构与内存的设计有关系，监控工
		具也会监控内存。所以内存结构处于 JVM 中核心位置。也是属于我们入门 JVM
		学习的最好的选择，同时JVM是一个虚拟化的操作系统，所以它要虚拟处理器（执行引擎），
		虚拟操作系统指令（基于操作数栈的指令集），虚拟操作系统内存（jvm内存区域），等等
		
		线程非共享区：
			1、虚拟机栈
				1、虚拟机栈是基于线程的：哪怕你只有一个 main() 方法，也是以线程的
			方式运行的。在线程的生命周期中，参与执行的方法栈帧会频繁地入栈和出
			栈，虚拟机栈的生命周期是和线程一样的。
				2、栈大小：每个虚拟机栈的大小缺省为 1M，可用参数 –Xss[size] 调整大小，
				可以参考官方文档（jdk1.8）：https://docs.oracle.com/javase/8/doc
				s/technotes/tools/unix/java.html
				3、堆栈溢出：栈帧深度压栈但并不出栈，导致栈空间不足，抛出java.lang.StackOverflowError ，典型的就是递归调用。
				
				栈帧的组成 栈帧大体都包含四个区域：(局部变量表、操作数栈、动态连接、返回地址)
					1、局部变量表：存放我们的局部变量的（方法内的变量）。首先它是一个32 位的长度，主要存放我们的 Java 的八大基础数据类型，
					一般 32 位就可以存放下，如果是 64 位的就使用高低位占用两个也可以存放下，如果是局部变量是一个对象，存放它的一个引用地址即可。
					2、操作数栈：存放 java 方法执行的操作数的，它也是一个栈，操作的的元素可以是任意的 java 数据类型，一个方法刚刚开始的时候操作数栈为空，操
					作数栈本质上是JVM执行引擎的一个工作区，方法在执行，才会对操作数栈进行操作。
					3、动态链接：Java 语言特性多态（后续细讲）
					4、完成出口：正常返回（调用程序计数器中的地址作为返回）、异常的话
					（通过异常处理器表<非栈帧中的>来确定）
			2、本地方法栈
				1、本地方法栈的功能和特点类似于虚拟机栈，均具有线程隔离的特点
				2、不同的是，本地方法栈服务的对象是JVM执行的native方法，而虚拟机
				栈服务的是JVM执行的java方法
				3、虚拟机规范里对这块所用的语言、数据结构、没有强制规定，虚拟机可
				以自由实现它
				4、hotspot把它和虚拟机栈合并成了1个
				5、和虚拟机栈一样，大小有限
			3、程序计数器
				较小的内存空间，存储当前线程执行的字节码的偏移量；各线程之间独立
				存储，互不影响，
				程序计数器主要用来记录各个线程执行的字节码的地址，例如，分支、循
				环、跳转、异常、线程恢复等都依赖于计数器。由于 Java 是多线程语言，当执
				行的线程数量超过 CPU 核数时，线程之间会根据时间片轮询争夺 CPU 资源。
				如果一个线程的时间片用完了，或者是其它原因导致这个线程的 CPU 资源被提
				前抢夺，那么这个退出的线程就需要单独的一个程序计数器，来记录下一条运
				行的指令。
				因为 JVM 是虚拟机，内部有完整的指令与执行的一套流程，所以在运行
				Java 方法的时候需要使用程序计数器（记录字节码执行的地址或行号），如果
				是遇到本地方法（native 方法），这个方法不是 JVM 来具体执行，所以程序计
				数器不需要记录了，这个是因为在操作系统层面也有一个程序计数器，这个会
				记录本地代码的执行的地址，所以在执行 native 方法时，JVM 中程序计数器的
				值为空(Undefined)。
				另外程序计数器也是 JVM 中唯一不会 OOM(OutOfMemory)的内存区域。
		线程非共享区：
			1、方法区
				方法区（Method Area）是可供各线程共享的运行时内存区域，主要用来
					存储已被虚拟机加载的类信息、常量、静态变量、JIT编译器编译后的代码缓存
					等等，它有个别名叫做：非堆（non-heap），主要是为了和堆区分开。
					方法区中存储的信息大致可分以下两类：
					1、类信息：主要指类相关的版本、字段、方法、接口描述、引用等
					2、运行时常量池：编译阶段生成的常量与符号引用、运行时加入的动态变
					量
				永久代 
					永久代是 hotspot 在1.7及之前才有的设计，1.8+，以及其他虚拟机并不存在这个东西。
					jdk 1.8+方法区大部分迁移到了 metaspace （注意不是全部，不是全部）
					永久代大小参数设置：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html
					-XX:PermSize ：初始大小 
					-XX:MaxPermSize ：最大值
				1.8+ 元空间
					从jdk1.8开始已经将方法区中实现的永久代去掉了，并用元空间（ classmetadata space ）代替了之前的永久代，
					元空间的存储位置是：本地内存/直接内存，并且将方法区大部分迁移到了元空间，注意不是方法区的全部。
					参数设置：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html
					-XX:MetaspaceSize ：元空间初始大小
					-XX:MaxMetaspaceSize ：可从本地内存为元空间分配出的最大值，默认是没有限制的
				方法区的一部分迁移到了元空间，具体哪些在元空间呢？还有什么不在元空间？
					1、元空间里主要存的是类的元数据（方法代码，变量名，方法名，访问权限，返回值等等）
					2、类加载的最终产品 Class 对象， static 成员，运行时常量池从物理存储上是在堆空间，逻辑上属于方法区。
				运行时常量池
					1、Class常量池（静态常量池）
						在 .class 文件中除了有类的版本、字段、方法和接口
							等描述信息外，还有一项信息是常量池 ( Constant Pool Table )，用于存放编
							译期间生成的各种字面量和符号引用，之所以说它是静态的常量池是因为这些
							都只是躺在 .class 文件中的静态数据，此时还没被加载到内存呢！，这点一定
							要理解。
					2、运行时常量池
					
					3、字符串常量池（没有明确的官方定义，其目的是为了更好的使用String ）
						字符串常量池这个概念是有争议的，很多正式的虚拟机规范文档，都没有
						对这个概念作一个明确的官方定义，所以字符串常量池与运行时常量池的关系
						不去抬杠，我们从它的作用和 JVM 设计它用于解决什么问题的点来分析它。
						以 JDK1.8 为例，字符串常量池是存放在堆中，并且与 java.lang.String
						类有很大关系。设计这块内存区域的原因在于： String 对象作为 Java 语言中
						重要的数据类型，是内存中占据空间最大的一个对象。高效地使用字符串，可
						以提升系统的整体性能。
					
			2、堆（Heap）是 JVM 上最大的内存区域，我们申请的几乎所有的对象，都是
在这里分配存储的。我们常说的垃圾回收，操作的对象就是堆
				堆结构
					1、堆被划分为新生代和老年代（ Tenured ），
					2、新生代与老年代的比例的值为 1:2 ，即：新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小；该值可以通过参数
					– XX:NewRatio 来指定 。
					3、新生代又被进一步划分为 Eden 和 Survivor 区， Survivor 由 From Survivor 和 To Survivor 组成，
					4、eden，from，to的大小比例为：8：1：1；可通过参数 -XX:SurvivorRatio 来指定
					5、JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。因此，新生代实际可
	用的内存空间为 9/10 ( 即90% )的新生代空间。
				堆的大小可由如下两个参数设置：
					-Xmssize：堆的初始大小，等价于 -XX:InitalHeapSize
					-Xmxsize：最大堆大小，等价于 -XX:MaxHeapSize
			JHSDB工具 查看堆信息
		
		直接内存：
			直接内存有一种更加科学的叫法，堆外内存（off-heap）。
			1、JVM 在运行时，会从操作系统申请大块的堆内存，进行数据的存储；同时还有虚拟机栈、本地方法栈和程序计数器，这块称之为栈区。操作系统剩余
	的内存也可以申请过来一块，也就是堆外内存。
			2、它不是虚拟机运行时数据区的一部分，也不是 java 虚拟机规范中定义的内存区域；
			3、如果使用了 NIO,这块区域会被频繁使用，主要是通过DirectByteBuffer 申请，在 java 堆内可以用 DirectByteBuffer 对象直接引用并操作；
			4、开发者也可以通过 Unsafe 或者其他 JNI 手段直接直接申请。
			5、这块内存不受 java 堆大小限制，但受本机总内存的限制，可以通过 -XX:MaxDirectMemorySize 来设置（默认与堆内存最大值一样），所以也会出现 OOM 异常。
			6、堆外内存的泄漏是非常严重的，它的排查难度高、影响大，甚至会造成主机的死亡
		注意：
		Oracle之前计划在Java 9中去掉 sun.misc.Unsafe API 。这里删除
		sun.misc.Unsafe 的原因之一是使Java更加安全，并且有替代方案。
	
	OOM：
		1、栈溢出
			1、对于 java.lang.StackOverflowError 一般的方法调用是很难出现的，如果出现了可能会是无限递归。
			虚拟机栈带给我们的启示：方法的执行因为要打包成栈桢，所以递归天生要比实现同样功能的循环慢，所以树的遍历算法中：递归和循环都有存在的意
	义。递归代码简洁，非递归代码复杂但是速度较快。
			2、 OutOfMemoryError Stack 的出现需要不断建立线程，JVM 申请栈内
	存，机器没有足够的内存。（一般演示不出，演示出来机器也死了）
			3、栈区的总空间大小 JVM 没有办法去限制的，因为 JVM 在运行过程中会有线程不断的运行，没办法限制，所以只限制单个虚拟机栈的大小，
		可通过 -Xss 设置
		
		2、堆溢出
		堆内存溢出：申请内存空间,超出最大堆内存空间。
			1、如果是内存溢出，则通过 调大 -Xms，-Xmx 参数。
			2、如果是内存泄漏（Memory Leak），就是说内存中的对象一直回收不掉，要使用工具查看泄露对象到 GC Roots 的引用链，找到泄露对象是通过怎样
			的路径与 GC Roots 相关联并导致垃圾收集器无法自动回收它们。
			3、如果不是内存泄露，也就是说内存中的对象的确都是必须存活的，那么应该检查 JVM 的堆参数设置，与机器的内存对比，看是否还有可以调整的空
			间， 再从代码上检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行时的内存消耗。
		3、方法区溢出
			1、运行时常量池溢出
			2、方法区中保存的 Class 信息占用的内存超过了我们配置或者 Class 对象该回收时没有被及时回收，比如有个参数：-Xnoclassgc ，就是禁用 Class 的回收，
			注意：Class 要被回收，条件比较苛刻（仅仅是可以，不代表必然，因
			为还有一些参数可以进行控制）：
				1、该类所有的实例都已经被回收，也就是堆中不存在该类的任何实
				例。
				2、 加载该类的 ClassLoader 已经被回收。
				3、 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法
				在任何地方通过反射访问该类的方法。
			代码示例：使用 cglib 不断生成 Class 并加载到内存，如何设置
MetaspaceSize 的大小 
			-XX:MetaspaceSize=10M -XX:MaxMetaspaceSize=10M
			出现以下错误！Exception in thread "main" java.lang.OutOfMemoryError:Metaspace
		4、直接内存溢出
			直接内存的容量可以通过 -XX:MaxDirectMemorySize 来设置（默认与堆内存最大值一样），所以也会出现 OOM 异常；
			由直接内存导致的内存溢出，一个比较明显的特征是在 HeapDump 文件中
			不会看见有什么明显的异常情况，如果发生了 OOM ，同时 Dump 文件很小，可以考虑重点排查下直接内存方面的原因
			
JAVA中的对象
	对象的创建过程：
		检查加载 首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用（符号引用 ：以一组符号来描述所引用的目标），并且检查类是否已经被加载、 解
析和初始化过。
		分配内存
			虚拟机将为新生对象分配内存。为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来，主要有两种分配内存的方式：
			
			指针碰撞:如果 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式
称为“指针碰撞”
			
			空闲列表
			如果 Java 堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录
上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”
			选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用
			的垃圾收集器是否带有压缩整理功能决定。 如果是 Serial、ParNew 等带有压
			缩的整理的垃圾回收器的话，系统采用的是指针碰撞，既简单又高效。如果是
			使用 CMS 这种不带压缩（整理）的垃圾回收器的话，理论上只能采用较复杂的空闲列表。
			
			并发安全
				除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情
				况下也并不是线程安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。
			解决这个问题主要依靠以下两种解决方案
			CAS
				对分配内存空间的动作进行同步处理——虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性
			TLAB
				另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个
				线程在 Java 堆中预先分配一小块私有内存，也就是本地线程分配缓冲（ Thread
				Local Allocation Buffer,TLAB ），JVM 在线程初始化时，同时也会申请一
				块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个
				Buffer ，如果需要分配内存，就在自己的 Buffer 上分配，这样就不存在竞争
				的情况，可以大大提升分配效率，当 Buffer 容量不够的时候，再重新从 Eden
				区域申请一块继续使用。
				TLAB 的目的是在为新对象分配内存空间时，让每个 Java 应用线程能在使
				用自己专属的分配指针来分配空间，减少同步开销。
				另外 TLAB 只是让每个线程拥有私有的分配指针，但底下存对象的内存空间
				还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个 TLAB
				用满时就重新申请一个 TLAB 。
				涉及到的参数： -XX:+UseTLAB ，允许在年轻代空间中使用线程本地分配块
				（ TLAB ）。默认情况下启用此选项。要禁用 TLAB ，请指定 -XX:-UseTLAB
		
		内存空间初始化：
			内存分配完成后，虚拟机需要将分配到的内存空间都初始化为默认值(如int 值为 0， boolean 值为 false 等等)。这一步操作保证了对象 的实例字段
		在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的默认值。
		所以在创建对象的过程中， 对象的成员属性存在着一个中间状态值，就是默认值。
		
		设置对象头
			虚拟机要对对象头（ object header ）进行必要的设置，例如markword ，这个对象是哪个类的实例、数字的长度等等这些信息！
		
		对象初始化
		上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚刚开始，所有的字段都还为默认值。所以，一般来说，执行 new 指令之后会接着把对象按照程序员的意愿进行初始
化(构造方法)，执行 init 函数，这样一个真正可用的对象才算完全产生出来。
		对象内存布局
			markword class pointer 实例数据  padding  8的整数倍
		对象的访问定位
			句柄访问：句柄方式：栈指针指向堆里的一个句柄的地址，这个句柄再定义俩指针分别指向类型和实例。
				好处是：垃圾回收时遇到对象内存地址的移动只需要修改句柄即可，不需
				要修改栈指针
				弊端是：寻址时多了一次操作。
			直接指针：
				直接地址：栈指针指向的就是实例本身的地址，在实例里封装一个指针指向它自己的类型。很显然，垃圾回收要移动对象时要改栈里的地址值，但是它减少了一次寻址操作。
				备注：hostspot使用的是直接地址方式
		各种引用
			强引用
			软引用 通过 SoftReference 构建软引用
			弱引用 ThreadLocal
			虚引用 通过 PhantomReference 构建虚引用
			
		对象的分配策略
			栈上分配
				在 JVM 开启逃逸分析后，如果对象没有逃逸，结合对象的大小等因素决定对象分配在栈上。其本质是Java虚拟机提供的一项优化技术。
				逃逸分析：
					JVM会分析对象的动态作用域，当一个对象在方法中定义后，它可能被外部所引用，称之为逃逸。
				比如：通过调用参数传递到其他方法中，称之为方法逃逸；赋值给其他线程中访问的变量，称之为线程逃逸。 
				从不逃逸到方法逃逸到线程逃逸，称之为对象由低到高的不同逃逸程度。开启逃逸分析需要配置以下参数：
				-XX:+DoEscapeAnalysis ：，默认开启
				如果开启逃逸分析，那么即时编译器（ Just-in-time Compilation，JIT ）在运行期就可以对代码做如下优化：
					（1）同步锁消除：如果确定一个对象不会逃逸出线程，即对象被发现只能被一个线程访问到，无法被其它线程访问到，那该对象的读写就不会存在竞
		争，对这个变量的同步锁就可以消除掉。
					使用 synchronized 的时候，如果 JIT 经过逃逸分析之后发现并无线程安全问题的话，就会做锁消除（注意是在运行时）
					锁消除在jdk1.8默认开启，可通过如下参数配置
					-XX:+EliminateLocks ：开启锁消除，锁消除基于逃逸分析基础之上，开
					启锁消除必须开启逃逸分析
					-XX:-EliminateLocks ： 关闭锁消除
					2）分离对象或标量替换。Java虚拟机中的原始数据类型（int，long等数值类型以及reference类型等）都不能再进一步分解，它们就可以称为标量。相
					对的，如果一个数据可以继续分解，那它称为聚合量，Java中最典型的聚合量是对象。如果逃逸分析证明一个对象不会被外部访问，并且这个对象是可分解
					的，那程序真正执行的时候将可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。拆散后的变量便可以被单独分析与优
					化， 可以各自分别在栈帧或寄存器上分配空间，原本的对象就无需整体分配空间了。
					标量替换需要添加以下 VM 参数
						-XX:+EliminateAllocations ，但前提是开启逃逸分析。并由此可见标量替换为栈上分配提供了很好的基础。
					-XX:+PrintEliminateAllocations 查看标量替换情况（Server VM 非Product版本支持）
				3）将堆分配转化为栈分配：栈上分配就是把方法中的变量和对象分配到栈上，方法执行完后栈自动销毁，而不需要垃圾回收的介入，从而提高系统性
				能。栈上分配基于逃逸分析和标量替换。
				栈上分配的优点：
					1、可以在函数调用结束后自行销毁对象，不需要垃圾回收器的介入，有效避免垃圾回收带来的负面影响
					2、栈上分配速度快，提高系统性能
					栈上分配的局限性： 栈空间小，对于大对象无法实现栈上分配
			优先分配在Eden
			大对象直接进入老年代
			长期存活对象进入老年代
			空间分配担保
GC垃圾回收，首要明确什么是垃圾？其实是内存，java中主要是针对对象，当一个对象不能再从正在运行的程序中的任何指针到达时，它就被认为是垃圾。
	对象存活判断
		引用计数法
		可达性分析
		来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为“GCRoots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为
引用链（ Reference Chain ），当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。
		作为 GC Roots 的对象包括下面几种（重点是前面 4 种）：
		虚拟机栈（栈帧中的本地变量表）中引用的对象；各个线程调用方法堆栈中使用到的参数、局部变量、临时变量等。
		方法区中类静态属性引用的对象；java 类的引用类型静态变量。
		方法区中常量引用的对象；比如：字符串常量池里的引用。
		本地方法栈中 JNI（即一般说的 Native 方法）引用的对象。
		JVM 的内部引用（ class 对象、异常对象 NullPointException 、
		OutofMemoryError ，系统类加载器）。（非重点）
		所有被同步锁( synchronized )持有的对象。（非重点）
		JVM 内部的 JMXBean 、 JVMTI 中注册的回调、本地代码缓存等（非重点）
		JVM 实现中的“临时性”对象，跨代引用的对象（在使用分代模型回收时
		只回收部分代的对象）（非重点）
		finalize：
		即使通过可达性分析判断不可达的对象，也不是“非死不可”，它还会处于“缓刑”阶段，真正要宣告一个对象死亡，需要经过两次标记过程，一次是没有找
到与 GCRoots 的引用链，它将被第一次标记。随后进行一次筛选（如果对象覆盖了 finalize ），我们可以在 finalize 中去拯救，俗称对象的自我救赎。需要注意的是：
			1、 finalize 只会执行一次，不会多次执行。
			2、建议大家尽量不要使用finalize，因为这个方法太不可靠
	
	GC算法理论
		分代回收理论
		当前商业虚拟机的垃圾回收器，大多遵循“分代收集”的理论来进行设计，这个理论大体上是这么描述的：
			1、 绝大部分的对象都是朝生夕死。
			2、 熬过多次垃圾回收的对象就越难回收。根据以上两个理论，朝生夕死的对象放一个区域，难回收的对象放另外一个区域，这个就构成了新生代和老年代，并且不同的分代采用的回收算法不一样
			
	同时对于GC的叫法，大体有这么几种：
			1、 新生代回收（ Minor GC/Young GC ）:指的是进行新生代的回收。
			2、 老年代回收（ Major GC/Old GC ）:指的是进行老年代的回收。目前只有 CMS 垃圾回收器会有这个单独的回收老年代的行为。（ Major GC 定义相对
没有那么明确，有说指是老年代，有的说是做整个堆的收集，这个需要你根据别人的场景来定，没有固定的说法，有时候 Major GC 和 Full GC 大致是等价
的）		3、 整堆回收（ Full GC ）：定义相对明确，收集整个 Java 堆和方法区（注意包含方法区）	
		复制算法
			1、将内存按容量划分为大小相等的两块，每次只使用其中的一块。
			2、当其中一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
			复制回收算法适合于新生代，因为大部分对象朝生夕死，那么复制过去的对象比较少，效率自然就高，另外一半的一次性清理是很快的
		标记-清除算法
		标记-清除（Mark-Sweep）算法分为“标记”和“清除”两个阶段：
			1、首先扫描所有对象标记出需要回收的对象，
			2、在标记完成后扫描并回收所有被标记的对象，故需要两次扫描
		标记-整理算法
			1、首先标记出所有需要回收的对象，
			2、在标记完成后，后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，
			3、然后直接清理掉端边界以外的内存标记
				整理算法适用于老年代。
	
	垃圾回收器
	SerialGC
		1、JVM 刚诞生就只有这种，比较古老，串行的，独占式，成熟，适合单CPU。
		2、比较适用于小数据集（约100M）的应用程序在多处理器上适用，超过这个大小的内存回收速度很慢，所以对于现在来说这个垃圾回收器已经是一个鸡肋。
		3、要启动可以通过参数： -XX:+UseSerialGC
		4、Minor GC 采用的是复制算法， Major GC 采用的是标记-整理算法。
	ParallerGC
		1、 Parallel Scavenge（ParallerGC） ：叫做并行收集器，关注的指标是吞吐量，它充分利用多核多线程使得 Minor GC 有着良好的性能表现，可以显
			着减少垃圾收集开销。线程数可通过 -XX:ParallelGCThreads=threads 设置，
			默认值取决于CPU核数。
		2、启用该收集器通过参数： -XX:+UseParallelGC 。
		3、吞吐量指标的定义：根据收集垃圾所花费的时间和应用程序时间的时间来衡量的，即吞吐量=应用程序执行时间/（应用程序执行时间+垃圾收集时
		间），比如：虚拟机总共运行了100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%。
		4、吞吐量指标可以通过参数： -XX:GCTimeRatio=<nnn> ，该设置表明垃圾回收时间与应用程序时间之比为 1 / (1 + <nnn> )。例如， -
		XX:GCTimeRatio=19 ，证明垃圾收集时间不能超过总时间的 1/20 即 5% 。5、开启并行压缩特性有助于在 Major GC 时采用多线程并行处理，否则
		Major GC 将采用单线程，默认情况下当我们使用 -XX:+UseParallelGC 启用并
		行收集器时，并行压缩特性也默认开启，当然也可以通过参数 -XX:-
		UseParallelOldGC 关闭。
		6、参数 -XX:+UseAdaptiveSizePolicy ：是一个开关， 当这个参数被激
		活之后，就不需要人工指定新生代的大小( -Xmn )、 Eden 与 Survivor 区的比例
		( -XX:SurvivorRatio )、 晋升老年代对象大小( -
		XX:PretenureSizeThreshold=value )等细节参数了，虚拟机会根据当前系统
		的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或
		者最大的吞吐量。默认开启。
		7、 Minor GC 采用的是复制算法， Major GC 采用的是标记-整理算法。
		8、适用于在多处理器或多线程硬件上运行的具有中型到大型数据集的应用
		程序。
	CMS
		CMS全称：Concurrent Mark Sweep，并发标记清除，该收集器开拓了并发回收的先河，是一种以获取最短 STW 时间为目标的收集器，它的主要特征
			如下：
			1、前面的收集器都是要停止用户线程的，而CMS收集器可以在某一阶段让用户线程和GC线程在同一时间一起工作，以减少 STW 时间，
			2、CMS主要用于回收老年代。
			3、使用CMS可以通过参数： -XX:+UseConcMarkSweepGC
			4、该垃圾回收器适合回收堆空间在 几个G~ 20G 左右
			5、从名字（包含 Mark Sweep ）上就可以看出，CMS 收集器是基于 标记—清除 算法实现的
		CMS的整体执行过程分成5个步骤，其中标记阶段包含了三步，具体细节如下：
			1、初始标记：标记 GC Roots 直接关联的对象，会导致 STW ，但是这个没多少对象，时间短 。
			2、并发标记：从 GC Roots 开始关联的所有对象开始遍历整个可达路径的对象，这步耗时比较长，所以它允许用户线程和GC线程并发执行，并不会导致
			STW ，但面临的问题是可能会漏标，标记变动等问题。
			3、重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段会导致 STW ，但是停顿时间一般会
			比初始标记阶段稍长一些，但远比并发标记的时间短。
			4、并发清除；将被标记的对象清除掉，因为是标记-清除算法，不需要移动存活对象，所以这一步与用户线程并发运行。
			5、重置线程：重置GC线程状态，等待下次CMS的触发，与用户线程同时运行。
		当然，在CMS中也会出现一些问题，主要有以下几点：
			1、CPU敏感：对处理器资源敏感，毕竟采用了并发的收集、当处理核心数不足 4 个时，CMS 对用户的影响较大
			2、浮动垃圾：由于 CMS 并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS
			无法在当次收集中处理掉它们，只好留待下一次 GC 时再清理掉，这一部分垃圾就称为“浮动垃圾”（比如用户线程运行产生了新的 GC Roots ）。
			由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收，在 1.6 的版本中老年代空间
			使用率阈值(92%) ；如果预留的内存不够存放浮动垃圾，就会出现 ConcurrentMode Failure ，这时虚拟机将临时启用 Serial Old 来替代 CMS。
			3、空间碎片：这是由于CMS采用的是标记-清除算法导致的，当碎片较多时，给大对象的分配带来很大的麻烦，为了解决这个问题，CMS 提供一个参
			数： -XX:+UseCMSCompactAtFullCollection （ HotSpot(TM) 64-BitServer VM is deprecated ），一般是开启的，如果分配不了大对象，就进行
			内存碎片的整理过程；这个地方一般会使用 Serial Old ，因为 Serial Old是一个单线程，回收时会暂停用户线程，然后进行空间整理。所以如果分配的
			对象较大，且较多时,CMS 发生这样的情况会很卡。
	ParNew
	多线程垃圾回收器，与 CMS 进行配合，对于 CMS(CMS 只回收老年代)，新生代垃圾回收器只有 Serial 与 ParNew 可以选。和 Serial 基本没区别，唯一的
区别：多线程，多 CPU 的，停顿时间比 Serial 少。（在 JDK9 以后，把ParNew 合并到了 CMS 了） 大致了解下搭配关系即可，后续版本已经接近淘汰
	
	G1全称：Garbage First，是一种服务器式垃圾收集器，针对具有大内存的多处理器机器。它试图以高概率满足垃圾收集 (GC) 暂停时间目标，同时实现
高吞吐量。G1是全堆操作且与应用程序线程并发执行，并通过多种技术实现高性能和暂停时间目标。G1的产生是为解决CMS算法产生空间碎片和其它一系列的问题
缺陷，oracle官方计划在jdk9中将G1变成默认的垃圾收集器，以替代CMS。JDK9默认G1为垃圾收集器的提案：https://openjdk.java.net/jeps/248，
将CMS标记为丢弃的提案：https://openjdk.java.net/jeps/291

参数设置
1、启用G1收集器： -XX:+UseG1GC 
2、设置分区大小： -XX:G1HeapRegionSize=value
3、设置最大GC暂停时间： -XX:MaxGCPauseMillis=time

1、如果应用程序追求低停顿，可以尝试选择G1；
2、经验值上，小内存6G以内，CMS优于G1，超过8G，尽量选择G1
3、是否代替CMS只有需要实际场景测试才知道。（如果使用G1后发现性
能还不如CMS，那么还是选择CMS）

类加载 
	系统加载器
		jvm提供了3个系统加载器，分别是Bootstrp loader、ExtClassLoader
		1）Bootstrp loaderBootstrp加载器是用C++语言写的，它在Java虚拟机启动后初始化
			它主要负责加载以下路径的文件：
			%JAVA_HOME%/jre/lib/*.jar
			%JAVA_HOME%/jre/classes/*
			-Xbootclasspath参数指定的路径
		2）ExtClassLoader
		ExtClassLoader是用Java写的，具体来说就是sun.misc.Launcher$ExtClassLoader
			ExtClassLoader主要加载：%JAVA_HOME%/jre/lib/ext/*
			ext下的所有classes目录
			java.ext.dirs系统变量指定的路径中类库
		3)AppClassLoader
			AppClassLoader也是用Java写成的，它的实现类是
			sun.misc.Launcher$AppClassLoader，另外我们知道ClassLoader中有个
			getSystemClassLoader方法，此方法返回的就是它。
			负责加载 -classpath 所指定的位置的类或者是jar文档
			也是Java程序默认的类加载器
		双亲委派
		类加载器加载某个类的时候，因为有多个加载器，甚至可以有各种自定义的，他们呈父子继承关系。
	这给人一种印象，子类的加载会覆盖父类，其实恰恰相反！与普通类继承属性不同，类加载器会优先调父类的load方法，如果父类能
	加载，直接用父类的，否则最后一步才是自己尝试加载，从源代码上可以验证。
	
	验证
		文件格式验证 元数据验证 字节码验证 符号引用验证
	分配内存内存空间并初始化
	