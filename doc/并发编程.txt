并发编程
		线程的创建
			1、继承Thread
			2、实现Runnable
			3、使用 lambda 表达式
			4、使用线程池
				1、通过execute方法提交Runnable任务到线程池中执行 无返回值，调用线程中获取不到异步线程的执行结果，除非通过共享变量
				2、通过submit方法提交Callable任务，结合Future，拿到返回值
			5、不使用线程池,通过new Thread 并获得异步线程的返回值，可以使用FutureTask
		线程的状态
			java中线程的生命周期，java中线程有6中状态分别如下：
				1、NEW：线程刚刚创建，还没启动
				2、RUNNABLE：可运行状态，由线程调度器调度执行，RUNNABLE又可分为两个部分，READY和RUNNING
				3、WAITING：等待被唤醒，处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。
				4、TIMED WAITING：超时被唤醒，处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒
				5、BLOCKED：线程等待获取一个锁，来继续执行下一步的操作，比较经典的就是 synchronized 关键字， synchronized 是需要经过操作系统调度的，
				只有这类情况线程状态才是BLOCKED,其他获取锁的情况是WAITING。
				6、TERMINATED：线程结束
		线程中断/打断
			1.线程中断的核心API public void interrupt(){}
			中断线程，但是这里仅仅只是设置了线程的中断标志位为true，中断之后线程是结束、还是等待新的任务或是继续运行至下一步，就取决于这个程序本
身（开发者决定）
			public boolean isInterrupted() {}查询线程是否被中断过，即查询中断标志位。
			public static boolean interrupted() {} 静态方法，查询当前线程是否被中断过，并重置中断标志位
			
			2、interrupt 遇到 wait，join，sleep如果线程被Object.wait, Thread.join和Thread.sleep三种方法之一阻塞，此时调用该线程的interrupt()方法，那么该线程将抛出一个
	InterruptedException中断异常（该线程必须事先预备好处理此异常，由开发者处理），从而提早地终结被阻塞状态。如果线程没有被阻塞，这时调用
	interrupt()将不起作用，直到执行到wait(),sleep(),join()时,才马上会抛出InterruptedException这也是一种可以让线程退出的解决方案。
	另外注意：在触发 InterruptedException 异常的同时，JVM 会同时把线程的中断标志位清除
			3、interrupt 遇到 synchronized/lock
				interrupt 能否打断锁的竞争过程呢？
				如果某一线程正在使用synchronized竞争锁，这个过程是无法被打断的。
				如果某一线程正在使用Lock（ReentrantLock）竞争锁，得分情况，如果是用 lock.lock() 获取锁，则竞争过程中无法被打断，如果是用
				lock.lockInterruptibly()获取锁，则竞争过程中是可以被打断的。
		线程退出
		结束一个线程有多少种方法？
			如果是正常退出，很简单， run 方法执行结束，线程就退出结束了；但是
			如果现在正在执行过程中需要结束退出该如何来做？
			1、stop 这是一种粗暴的线程终止行为，在线程终止之前没有对其做任何的清除操作，因此具有固有的不安全性。（类似直接拔电源），比如：如果线程持有
ReentrantLock 锁，被 stop() 的线程并不会自动调用 ReentrantLock 的unlock() 去释放锁，那其他线程就再也没机会获得 ReentrantLock 锁，这实在是太危险了。
			2、suspend+resume
			不建议使用，原因是suspend有死锁的风险，如果某一线程正持有一把锁，suspend是不会释放的，只有等该线程再次恢复后才有可能释放，这其中就有死锁的风险。
			3、volatile 共享变量（标志位）
			4、interrupt() + isInterrupted() / Thread.interrupted() / InterruptedException
=============================================================================================================================================	
线程三大特性 可见性：Visibility 有序性：Ordering 原子性：Atomicity
		JMM(Java Memory Model) 
				JMM 规定了所有的变量都存储在主内存（Main Memory）中。每条线程还有自己的工作内存（Working Memory），
		工作内存中保留了该线程使用到的变量的主内存的副本。工作内存是 JMM 的一个抽象概念，并不真实存在，它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。
		线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程间也无法直接访问对方工作内存中的变量，线程间变量
		值的传递均需要通过主内存来完成。
		注意：为了获得较好的执行效能，
			1、JMM 并没有限制执行引擎使用处理器的特定寄存器或缓存来和主存进行交互，
			2、JMM 也没有限制即时编译器调整指令执行顺序这类优化措施
		JMM解决什么问题？
			1、工作内存数据一致性：可见性问题
	各个线程操作数据时会使用工作内存中的主内存中共享变量副本，当多个线程的运算任务都涉及同一个共享变量时，可能导致各自的共享变量副本不一
	致。如果真的发生这种情况，数据同步回主内存以谁的副本数据为准？Java 内存模型主要通过一系列的数据同步协议、规则来保证数据的一致性。
			2、约束指令重排序优化：有序性问题
			Java 中重排序通常是编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段。重排序可分为两类：编译期重排序和运行期
	重排序(处理器乱序优化)，分别对应编译时和运行时环境。同样的，指令重排序不是随意重排序，它需要满足以下几个条件：
			在单线程环境下不能改变程序运行的结果。即时编译器（和处理器）需要保证程序能够遵守 as-if-serial 属性。通俗地说，就是在单线程情
	况下，要给程序一个顺序执行的假象。即使经过重排序后的执行结果要与顺序执行的结果保持一致。存在数据依赖关系的不允许重排序。
	多线程环境下，如果线程处理逻辑之间存在依赖关系，有可能因为指令重排序导致运行结果与预期不同。
		JMM内存交互
						JMM 定义了 8 个操作来完成主内存和工作内存之间的交互操作。JVM 实现时必须保证下面介绍的每种操作都是 原子的（对于 double 和 long 型的变量来
				说，load、store、read、和 write 操作在某些平台上允许有例外 ）。
				lock (锁定) - 作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
				unlock (解锁) - 作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
				read (读取) - 作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。
				load (载入) - 作用于工作内存的变量，它把 read 操作从主内存中得到的变量值放入工作内存的变量副本中。
				use (使用) - 作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值得字节码指令时就会执行这个操作。
				assign (赋值) - 作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
				store (存储) - 作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后 write 操作使用。
				write (写入) - 作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。
				如果要把一个变量从主内存中复制到工作内存，就需要按序执行 read 和load 操作；如果把变量从工作内存中同步回主内存中，就需要按序执行
				store 和 write 操作。但 Java 内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。
			JMM 还规定了上述 8 种基本操作，需要满足以下规则：
				1. read 和 load 必须成对出现；store 和 write 必须成对出现。即不允许一个变量从主内存读取了但工作内存不接受，或从工作内存发起回写了但主内存不接受的情况出现。
				2. 不允许一个线程丢弃它的最近 assign 的操作，即变量在工作内存中改变了之后必须把变化同步到主内存中。
				3. 不允许一个线程无原因的（没有发生过任何 assign 操作）把数据从工作内存同步回主内存中。
				4. 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load 或 assign ）的变量。换句话说，就是对一个变量实施 use 和 store 操作之前，必须先执行过了 load 或 assign 操作。
				5. 一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。所以 lock 和 unlock 必须成对出现。
				6. 如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。
				7. 如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定的变量。
				8. 对一个变量执行 unlock 操作之前，必须先把此变量同步到主内存中（执行 store 和 write 操作）
					注意：规则6，规则8需要大家留意一下！！！
		Happens-Before 它真正要表达的是：前面一个操作的结果对后续操作是可见的。Happens-Before 约束了编译器的优化行为，虽允许编译器优化，但是要求
编译器优化后一定遵守 Happens-Before 规则，具体的一些规则如下：
			1、程序的顺序性规则
			2、volatile 变量规则
			3、管程中锁的规则 管程（Monitors，也称为监视器），是一种通用的同步原语，能够实现对
	共享资源的互斥访问，Java 中指的就是 synchronized，synchronized 是 Java里对管程的实现
			4、线程启动规则
		它是指主线程 A 启动子线程 B 后，子线程 B 能够看到主线程在启动子线程B 前的操作。
			5、线程join规则 它是指主线程 A 等待子线程 B 完成（主线程 A 通过调用子线程 B 的 join()
方法实现），当子线程 B 完成后（主线程 A 中 join() 方法返回），主线程能够看到子线程的操作。当然所谓的“看到”，指的是对共享变量的操作结果可见。
			6、线程中断规则
			对线程 interrupt() 方法的调用 Happens-Before 被中断线程的代码检测到中断事件的发生，比如我们可以通过Thread.interrupted()/isInterrupted 方法检测到是否有中断发生。
			7、对象终结规则
			一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。
	可见性解决方案
		volatile：
			volatile 变量的两个特性：
				保证变量对所有线程的可见性：当一条线程修改了 volatile 变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点
					线程写 volatile 变量的过程：
						1. 改变线程工作内存中 volatile 变量副本的值
						2. 将改变后的副本的值立即从工作内存刷新到主内存
					注意:
						1、volatile并不能保证并发操作的原子性，即不保证线程安全
						2、volatile修饰引用类型，它只能保证引用本身的可见性，不能保证所引用对象内部属性的可见性
		synchronized：
		synchronized 加锁的含义不仅仅局限于互斥行为，还包括内存可见性。执行解锁操作时会将工作内存中的共享变量刷到主内存（相当于JMM中的unlock ）。
			执行加锁操作时会清空工作内存中共享变量副本的值，需要使用时从主内存重新加载（相当于JMM中的 lock ）。
			但是要注意的是：使用锁来保证可见性太笨重，因为 synchronized 是线程独占的，其他线程会被阻塞，这里面还存在一些线程调度开销，因为它是靠操
			作系统内核互斥锁实现的。而 volatile 是相对轻量级的，但是 synchronized除了保证可见性还能保证原子性，而 volatile 不能保证原子性。
		final：
			final 修饰变量时代表它是不可变的，既然是不可变的，也就不存在不同线程间工作内存数据不一致的问题，而且编译器想怎么优化怎么优化，
			一个对象的final字段值是在它的构造方法里面设置的（或者声明时直接初始化）。假设对象被正确的构造了，一旦对象被构造，在构造方法里面设置给
			final字段的的值在没有同步的情况下对所有其他的线程都会可见。另外，引用这些final字段的对象或数组都将会看到final字段的最新值
	有序性解决方案
		volatile 一是能保证变量对所有线程的可见性，解决可见性问题，二是禁止进行指令重排序，解决的就是有序性问题。
		另外：synchronized 虽不能禁止指令重排，但能保证有序性
		内存屏障 volatile底层也是基于内存屏障实现。
	原子性解决方案
		加锁是我们能想到的最直接也是最通用的互斥解决方案 
		synchronized
			1、加锁和解锁操作在哪里体现的？synchronized 的加锁和解锁是隐式实现的，可以查看字节码
			2、synchronized 的锁对象是什么，也就是说锁定的是哪个对象？
				如果修饰的是代码块，锁对象是我们自己指定的，指定哪个对象就锁定哪个对象。
				如果修饰的是非静态方法，锁定的是当前实例对象 this 。
				如果修饰的是静态方法，锁定的是当前类的 Class 对象。
		解决 i+=1 问题
		锁和资源的关系
			一个合理的关系是：锁和受保护资源之间的关联关系是 1：N 的关系。
		死锁
		如何打破死锁？
			如果程序真的发生了死锁，一般没有特别好的办法，很多时候只能重启应用，所以我们一般是探究如何发现死锁以及在编写程序的时候
			1、如何发现死锁？jps ， jstack ， jconsole ， jvisualvm 等工具
	
	安全，活跃，性能问题
	
	wait() 方法和 sleep() 方法都能让当前线程挂起一段时间，那它们的区别是什么？
		wait与sleep不同点在于：
		wait是Object中的方法，Sleep是Thread中的方法
		wait会释放所有锁而sleep不会释放锁资源.
		wait只能在同步方法和同步块中使用，而sleep任何地方都可以
		两者相同点：都会让出CPU执行时间，等待再次调度！
		
	CAS：
		CAS（Compare-and-Swap/Exchange），即比较并替换，是一种实现并发常用到的技术
		循环体内是做计算， while 中是进行 CAS 操作，这样通过不断循环并通过
		CAS修改值的方式我们叫做自旋。
		CAS虽然很高效的解决了原子操作问题，但是CAS仍然存在三大问题。
			1. 自旋(循环)时间长开销很大，如果CAS失败，会一直进行尝试。如果CAS长时间一直不成功，可能会给CPU带来很大的开销，注意这里的自
			旋是在用户态/SDK 层面实现的。
			2. 只能保证一个共享变量的原子操作，对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。
			3. ABA问题，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比CAS更高效。
	Lock&Condition
		并发编程领域，有两大核心问题：一个是互斥，即同一时刻只允许一个线程访问共享资源；另一个是同步，即线程之间如何通信、协作。
synchronized ， wait ， notify/notifyAll ，这套组合就可以用来解决互斥和同步的问题，这是JDK在语言层面提供的一种实现，另外JDK在SDK层面
还提供了另外一种实现（特别注意这是java SDK层面），那就是 Lock 和Condition ，那这算不算重复造轮子呢？
		答案不是，这两套实现之间是有巨大区别的，区别是什么呢？
			1、 synchronized 在已经获取了锁A的情况下去获取锁B，如果锁B获取不到，它不会释放锁A
			2、 synchronized 获取锁B时获取不到时会进入阻塞状态，啥也干不了，
			也不能被中断/打断，也就无法去释放已获得的资源
			这也是我们发生死锁时的两个条件：1，保持和等待；2，不可被剥夺/抢占
			所以针对 synchronized 的这些弊端，我们的并发大师 Doug Lea 提供了
			JUC 下的诸多实现，而他提供的新的锁具备以下这几个特征：
			1、能够被中断：这个解决的就是 synchronized 获取不到锁时进入阻塞，也不能被中断的特性，如果获取不到锁进入阻塞后还能收到中断信号被唤醒，
那么它就有机会去释放曾经锁定过的资源，避免死锁。
			2、支持超时获取：如果线程在一段时间之内没有获取到锁，不是进入一直阻塞的状态，而是返回一个错误，那这个线程也有机会释放曾经持有的锁，避免死锁
			3、支持非阻塞的获取锁：如果尝试获取锁失败，并不进入阻塞状态，而是直接返回，那这个线程也有机会释放曾经持有的锁，避免死锁
				体现在 API 上，就是 Lock 接口的几个方法，如下：
				// 支持中断的API
				void lockInterruptibly() throws InterruptedException;
				// 支持超时获取的API
				boolean tryLock(long time, TimeUnit unit) throws
				InterruptedException;
				// 支持非阻塞获取锁的API
				boolean tryLock();
				//普通获取锁的API
				void lock();
				//释放锁
				void unlock();
				//条件变量
				Condition newCondition();
		在使用 synchronized 时，我们要配合使用 wait ， notify/notifyAll 来进行线程的等待和通知，而在使用 Lock 时我们需要使用 Condition 中提供的
await() 、 signal() 、 signalAll() ，并且一个 Lock 是可以支持多个Condition 的；它们的语义和 wait() 、 notify() 、 notifyAll() 是相同
的。但要注意的是这两套不能错乱使用，Lock&Condition 只能使用前面的await()、signal()、signalAll()，而后面的 wait()、notify()、notifyAll() 只有在
synchronized 里才能使用。

		Semaphore：
			1、互斥信号量：任务之间通过互斥信号量访问临界资源，这其实就是锁机制
			2、计数信号量：任务之间竞争性的访问共享资源
			3、二值信号量：任务之间的同步机制
			所以说：信号量是操作系统提供的管理资源共享的有效手段。
			在 Java SDK 里面，信号量模型是由 java.util.concurrent.Semaphore实现的。（Semaphore跟 ReentrantLock 一样也分公平和不公平，默认不公
	平）Semaphore 这个类对应的几个操作分别是： acquire() ， release() ，
			对于信号量的使用一般有以下几种，比如：
				1、互斥信号量，充当互斥锁、
				2.计数信号量：实现一个限流器，比较常见的需求就是我们工作中遇到的各种池化资源，例如连接池、对象池、线程池等等。其中，你可能最熟悉数据库连接池，在同一时刻，一定是允许多个线程同时使用连接池的，当然，每个
			连接在被释放前，是不允许其他线程使用的。
		ReadWriteLock：读多写少
		StampedLock
		CountDownLatch&CyclicBarrier
	AQS框架
		AQS（AbstractQueuedSynchronizer）：抽象队列同步器，定义了一套多
	线程访问共享资源的同步器框架，提供了SDK层面的锁机制，JUC中的很多类譬
	如：ReentrantLock/Semaphore/CountDownLatch......等都是基于它。
		1、AQS用一个 volatile int state; 属性表示锁状态，1表示锁被持有，0表示未被持有，具体的维护由子类去维护，但是提供了修改该属性的三个方
	法： getState() ， setState(int newState) ， compareAndSetState(intexpect, int update) ，其中CAS方法是核心。
		2、框架内部维护了一个FIFO的等待队列，是用双向链表实现的，我们称之为CLH队列，
		3、框架也内部也实现了条件变量 Condition ，用它来实现等待唤醒机制，并且支持多个条件变量
		4、AQS支持两种资源共享的模式：独占模式（Exclusive）和共享模式（Share），所谓独占模式就是任意时刻只允许一个线程访问共享资源，譬如
			ReentrantLock；而共享模式指的就是允许多个线程同时访问共享资源，譬如Semaphore/CountDownLatch
		5、使用者只需继承 AbstractQueuedSynchronizer 并重写指定的方法，在方法内完成对共享资源 state 的获取和释放，至于具体线程等待队列的维
	护，AQS已经在顶层实现好了，在那些 final 的模板方法里。
	
		并发容器
		线程池